/**
 * Semantic Search Engine for TraceBack (Vector-based)
 * Uses dense vector embeddings (generated by offscreen Transformers.js)
 * and hybrid ranking (Vector Similarity + Metadata Boosting)
 */

export class SemanticSearch {
  constructor() {
    this.storageManager = null;
  }

  setStorageManager(manager) {
    this.storageManager = manager;
  }

  /**
   * Build/Load index
   * In this vector-based approach, the "index" is primarily just the stored vectors.
   * We do a simple pass to ensure we're ready.
   */
  async buildIndex(captures) {
    console.log(`üîç Semantic Search: Index ready (${captures.length} docs)`);
    // Future optimization: Build HNSW index here if array is too large
  }

  /**
   * Add a single capture to the index (No-op in simple brute-force)
   */
  addToIndex(capture) {
    // In a flat array scan, we don't need to do anything complex here
    // as long as the capture is in the storage/list passed to search()
  }

  /**
   * Calculate Cosine Similarity
   * @param {Array<number>} vecA 
   * @param {Array<number>} vecB 
   */
  cosineSimilarity(vecA, vecB) {
    if (!vecA || !vecB || vecA.length !== vecB.length) return 0;

    let dot = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < vecA.length; i++) {
      dot += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }

    if (normA === 0 || normB === 0) return 0;
    return dot / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  /**
   * Perform Hybrid Search
   * @param {string} query - Raw text query
   * @param {Array} captures - List of documents to search
   * @param {Array<number>} [queryVector] - Embedding of the query
   */
  async search(query, captures, queryVector) {
    const results = [];
    const lowerQuery = query.toLowerCase();

    // 1. Iterate over all captures
    // Note: For < 1000 docs, brute-force cosine similarity is extremely fast (< 10ms)
    // For larger datasets, we would implement an Inverted File Index (IVF) or HNSW.

    for (const capture of captures) {
      let score = 0;
      let vectorScore = 0;
      let matchType = 'none';

      // --- A. Semantic Vector Score ---
      if (queryVector && capture.embedding) {
        vectorScore = this.cosineSimilarity(queryVector, capture.embedding);
        if (vectorScore > 0.1) { // Lower threshold for broader conceptual matches (lion -> animal, cat -> pet, etc.)
          score += vectorScore * 200; // Boosted score (0-200)
          matchType = 'semantic';
        }
      }

      // --- B. Keyword/Metadata Boosting (Hybrid) ---

      // Title Exact Match
      if (capture.title?.toLowerCase().includes(lowerQuery)) {
        score += 50;
        matchType = matchType === 'semantic' ? 'hybrid' : 'exact';
      }

      // Exact URL Match
      if (capture.url?.toLowerCase().includes(lowerQuery)) {
        score += 30;
      }

      // OCR Content Match (Visual Search)
      if (capture.ocrText?.toLowerCase().includes(lowerQuery)) {
        score += 20;
      }

      // Recency Boost (Decay over 7 days)
      const ageHours = (Date.now() - capture.timestamp) / (1000 * 60 * 60);
      const recencyBoost = Math.max(0, 10 - (ageHours / 24)); // Up to +10 points for new stuff
      score += recencyBoost;

      if (score > 5) { // Lower minimum score to show more results, especially for semantic matches
        results.push({
          ...capture,
          searchScore: score,
          vectorScore: vectorScore * 100,
          matchType
        });
      }
    }

    // Sort by score
    return results.sort((a, b) => b.searchScore - a.searchScore).slice(0, 50);
  }
}

export default SemanticSearch;

