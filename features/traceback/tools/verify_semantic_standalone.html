<!DOCTYPE html>
<html>
<head>
    <title>Semantic Search Verification (Standalone)</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        .success { color: green; font-weight: bold; }
        .failure { color: red; font-weight: bold; }
        .log { background: #f0f0f0; padding: 10px; border-radius: 5px; font-family: monospace; white-space: pre-wrap; }
    </style>
</head>
<body>
    <h2>Semantic Search Logic Verification</h2>
    <div id="status">Running Verification...</div>
    <div id="results"></div>
    <div id="logs" class="log"></div>

    <script>
        // Log helper
        function log(msg) {
            console.log(msg);
            document.getElementById('logs').textContent += msg + '\n';
        }

        // --- EMBEDDED SemanticSearch Class (Synced with lib/semantic-search.js) ---
        class SemanticSearch {
          constructor() {
            this.vocabulary = new Map(); // Word to index mapping
            this.idf = new Map(); // Inverse document frequency
            this.documentVectors = new Map(); // Document ID to TF-IDF vector
            this.aiSession = null;
          }
        
          /**
           * Build vocabulary and IDF from all documents
           */
          async buildIndex(captures) {
            log('üîç Building semantic search index...');
        
            // Step 1: Build vocabulary
            const documentFrequency = new Map();
            const totalDocs = captures.length;
        
            captures.forEach(capture => {
              const text = this.preprocessText(
                `${capture.title} ${capture.url} ${capture.extractedText || capture.domText || ''}`
              );
              const words = new Set(text.split(/\s+/).filter(w => w.length > 2));
        
              words.forEach(word => {
                if (!this.vocabulary.has(word)) {
                  this.vocabulary.set(word, this.vocabulary.size);
                }
                documentFrequency.set(word, (documentFrequency.get(word) || 0) + 1);
              });
            });
        
            // Step 2: Calculate IDF
            this.vocabulary.forEach((index, word) => {
              const df = documentFrequency.get(word) || 1;
              this.idf.set(word, Math.log(totalDocs / df));
            });
        
            // Step 3: Build TF-IDF vectors for each document
            captures.forEach(capture => {
              const vector = this.buildTFIDFVector(capture);
              this.documentVectors.set(capture.id, vector);
            });
        
            log(`‚úÖ Indexed ${totalDocs} documents with ${this.vocabulary.size} terms`);
          }
        
          /**
           * Preprocess text (lowercase, remove special chars, stem)
           */
          preprocessText(text) {
            return text
              .toLowerCase()
              .replace(/[^\w\s]/g, ' ')
              .replace(/\s+/g, ' ')
              .trim();
          }
        
          /**
           * Build TF-IDF vector for a document
           */
          buildTFIDFVector(capture) {
            const text = this.preprocessText(
              `${capture.title || ''} ${capture.url || ''} ${capture.extractedText || capture.domText || ''}`
            );
            const words = text.split(/\s+/).filter(w => w.length > 2);
        
            // Calculate term frequency
            const tf = new Map();
            words.forEach(word => {
              tf.set(word, (tf.get(word) || 0) + 1);
            });
        
            // Normalize by document length
            const totalWords = words.length || 1;
        
            // Build sparse vector
            const vector = new Map();
            tf.forEach((count, word) => {
              if (this.vocabulary.has(word)) {
                const termFreq = count / totalWords;
                const idfValue = this.idf.get(word) || 0;
                vector.set(word, termFreq * idfValue);
              }
            });
        
            return vector;
          }
        
          /**
           * Calculate cosine similarity between two vectors
           */
          cosineSimilarity(vec1, vec2) {
            let dotProduct = 0;
            let mag1 = 0;
            let mag2 = 0;
        
            // Get all unique terms
            const allTerms = new Set([...vec1.keys(), ...vec2.keys()]);
        
            allTerms.forEach(term => {
              const v1 = vec1.get(term) || 0;
              const v2 = vec2.get(term) || 0;
        
              dotProduct += v1 * v2;
              mag1 += v1 * v1;
              mag2 += v2 * v2;
            });
        
            if (mag1 === 0 || mag2 === 0) return 0;
        
            return dotProduct / (Math.sqrt(mag1) * Math.sqrt(mag2));
          }
        
          /**
           * Expand query using AI for semantic understanding
           */
          async expandQuery(query) {
            try {
              if (!this.aiSession) {
                // Check if Prompt API is available (LanguageModel is the official global API)
                // Use self.LanguageModel to support Service Workers/Background Scripts
                const ModelClass = (typeof self !== 'undefined' ? self : window).LanguageModel;
        
                if (typeof ModelClass === 'undefined') {
                  log('Note: LanguageModel API not found, falling back to basic search.');
                  return [query]; // Return original query if AI not available
                }
        
                const availability = await ModelClass.availability({
                  expectedInputs: [{ type: 'text', languages: ['en'] }],
                  expectedOutputs: [{ type: 'text', languages: ['en'] }]
                });
                if (availability === 'unavailable') {
                    log('Note: AI Model unavailable.');
                  return [query];
                }
        
                this.aiSession = await ModelClass.create({
                  expectedInputs: [{ type: 'text', languages: ['en'] }],
                  expectedOutputs: [{ type: 'text', languages: ['en'] }],
                  systemPrompt: 'You are a search query expansion assistant. Generate related search terms.'
                });
              }
        
              // Ask AI to expand the query with synonyms and related terms
              const prompt = `For the search query "${query}", provide 3-5 related search terms or synonyms that would help find similar content. Return ONLY the terms, comma-separated, no explanations.`;
        
              const response = await this.aiSession.prompt(prompt);
        
              // Parse response
              const expandedTerms = response
                .split(',')
                .map(t => t.trim().toLowerCase())
                .filter(t => t.length > 0)
                .slice(0, 5);
        
              return [query, ...expandedTerms];
        
            } catch (error) {
              log('Query expansion failed, using original query: ' + error);
              return [query];
            }
          }
        
          /**
           * Semantic search with expanded queries
           */
          async search(query, captures) {
            // Expand query with AI
            const expandedQueries = await this.expandQuery(query);
            log('üîç Expanded query: ' + JSON.stringify(expandedQueries));
        
            // Build query vector from expanded terms
            const queryText = expandedQueries.join(' ');
            const queryVector = this.buildQueryVector(queryText);
        
            // Calculate similarity scores
            const scores = captures.map(capture => {
              const docVector = this.documentVectors.get(capture.id);
              if (!docVector) return { capture, score: 0 };
        
              const similarity = this.cosineSimilarity(queryVector, docVector);
        
              // Boost for exact matches in title/URL
              let boost = 1;
              const lowerQuery = query.toLowerCase();
              if (capture.title?.toLowerCase().includes(lowerQuery)) boost *= 1.5;
              if (capture.url?.toLowerCase().includes(lowerQuery)) boost *= 1.3;
        
              return {
                capture,
                score: similarity * boost * 100 // Scale to percentage
              };
            });
        
            // Sort by score and return captures with searchScore property
            return scores
              .filter(s => s.score > 0)
              .sort((a, b) => b.score - a.score)
              .map(s => ({
                ...s.capture,
                searchScore: s.score
              }));
          }
        
          /**
           * Build query vector from text
           */
          buildQueryVector(queryText) {
            const text = this.preprocessText(queryText);
            const words = text.split(/\s+/).filter(w => w.length > 2);
        
            const tf = new Map();
            words.forEach(word => {
              tf.set(word, (tf.get(word) || 0) + 1);
            });
        
            const totalWords = words.length || 1;
            const vector = new Map();
        
            tf.forEach((count, word) => {
              if (this.vocabulary.has(word)) {
                const termFreq = count / totalWords;
                const idfValue = this.idf.get(word) || 0;
                vector.set(word, termFreq * idfValue);
              }
            });
        
            return vector;
          }
        
          /**
           * Update index with new capture
           */
          addToIndex(capture) {
            const text = this.preprocessText(
              `${capture.title} ${capture.url} ${capture.extractedText || capture.domText || ''}`
            );
            const words = new Set(text.split(/\s+/).filter(w => w.length > 2));
        
            // Update vocabulary if needed
            words.forEach(word => {
              if (!this.vocabulary.has(word)) {
                this.vocabulary.set(word, this.vocabulary.size);
                this.idf.set(word, 1); // Will be updated on next full rebuild
              }
            });
        
            // Build vector for new document
            const vector = this.buildTFIDFVector(capture);
            this.documentVectors.set(capture.id, vector);
          }
        }
        // --- END EMBEDDED CODE ---


        async function runTest() {
            const statusDiv = document.getElementById('status');
            const resultsDiv = document.getElementById('results');
            let output = '';
            let failureCount = 0;

            // --- FUNCTION: Run a single test case ---
            async function runCase(name, setupFn, verifyFn) {
                try {
                    window.LanguageModel = { availability: async () => 'readily' };
                    const engine = new SemanticSearch();
                    const { docs, query } = await setupFn(engine);
                    await engine.buildIndex(docs); // Build index inside runCase
                    const results = await engine.search(query, docs);
                    const result = verifyFn(results);
                    
                    if (result.passed) {
                        output += `<div class="success">‚úÖ ${name}: PASSED</div>`;
                        output += `<div style="margin-left:20px; font-size:0.9em; color:#555;">${result.message}</div>`;
                    } else {
                        failureCount++;
                        output += `<div class="failure">‚ùå ${name}: FAILED</div>`;
                        output += `<div style="margin-left:20px; font-size:0.9em;">Reason: ${result.message}</div>`;
                        output += `<div style="margin-left:20px; font-size:0.8em;">Scores: ${results.map(r => `${r.title}=${r.searchScore.toFixed(2)}`).join(', ')}</div>`;
                    }
                } catch (e) {
                    failureCount++;
                    output += `<div class="failure">‚ùå ${name}: ERROR</div>`;
                    output += `<div style="margin-left:20px;">${e.message}</div>`;
                    console.error(e);
                }
                output += '<hr/>';
            }

            // --- TEST 1: Exact vs Semantic Ranking ---
            await runCase('Test 1 (Exact vs Semantic)', 
                async (engine) => {
                    window.LanguageModel.create = async () => ({
                        prompt: async () => 'vehicle, automobile, bmw'
                    });
                    
                    const docs = [
                        { id: 1, title: "Doc BMW", url: "http://b.com", domText: "I have a BMW.", timestamp: Date.now() },
                        { id: 2, title: "Doc Car", url: "http://c.com", domText: "I have a Car.", timestamp: Date.now() },
                        { id: 99, title: "Noise", url: "http://z.com", domText: "Just some random text to adjust IDF.", timestamp: Date.now() }
                    ];
                    return { docs, query: 'Car' };
                },
                (results) => {
                    if (results.length < 2) return { passed: false, message: `Found ${results.length} results, expected at least 2.` };
                    const top = results[0];
                    if (top.id === 2) return { passed: true, message: `Exact match "Car" (${top.searchScore.toFixed(2)}) ranked #1.` };
                    return { passed: false, message: `Semantic match "BMW" (${top.searchScore.toFixed(2)}) outranked Exact match.` };
                }
            );

            // --- TEST 2: Fuzzy Logic (Typo) ---
            await runCase('Test 2 (Typo Correction)',
                async (engine) => {
                    window.LanguageModel.create = async () => ({
                        prompt: async (t) => t.includes('Vehcle') ? 'vehicle' : ''
                    });

                    const docs = [
                        { id: 1, title: "Target", url: "http://f.com", domText: "This is a Vehicle.", timestamp: Date.now() },
                        { id: 99, title: "Noise", url: "http://z.com", domText: "Nothing related here.", timestamp: Date.now() }
                    ];
                    return { docs, query: 'Vehcle' };
                },
                (results) => {
                    if (results.length > 0) return { passed: true, message: `Found "Vehicle" doc using typo "Vehcle" via expansion.` };
                    return { passed: false, message: `No results found for "Vehcle".` };
                }
            );

            // --- TEST 3: Title Weighting ---
            await runCase('Test 3 (Title Weighting)',
                async (engine) => {
                    window.LanguageModel.create = async () => ({
                        prompt: async () => 'fruit'
                    });

                    const docs = [
                        { id: 1, title: "Banana", url: "http://fruit.com", domText: "Just a fruit.", timestamp: Date.now() },
                        { id: 2, title: "Other", url: "http://other.com", domText: "I like Banana.", timestamp: Date.now() },
                        { id: 99, title: "Noise", url: "http://z.com", domText: "Apple Orange Pear but not the b-word.", timestamp: Date.now() }
                    ];
                    return { docs, query: 'Banana' };
                },
                (results) => {
                    const targets = results.filter(r => r.id === 1 || r.id === 2);
                    if (targets.length < 2) return { passed: false, message: `Not enough target results found (${targets.length}). Scores: ${results.map(r=>r.searchScore).join(',')}` };
                    
                    if (targets[0].id === 1) return { passed: true, message: `Title match (${targets[0].searchScore.toFixed(2)}) > Body match (${targets[1].searchScore.toFixed(2)}).` };
                    return { passed: false, message: `Body match (${targets[0].searchScore.toFixed(2)}) outranked Title match.` };
                }
            );

            resultsDiv.innerHTML = output;
            statusDiv.textContent = failureCount === 0 ? 'Verification Suite Passed' : 'Verification Suite Failed';
        }

        runTest();
    </script>
</body>
</html>
